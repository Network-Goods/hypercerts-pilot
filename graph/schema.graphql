# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Contributor {
    hypercerts(first: Int = 100, orderBy: Hypercert_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Hypercert_filter): [Hypercert!]!
    id: String!
}

type Hypercert {
    claimHash: Bytes!
    contributors(first: Int = 100, orderBy: Contributor_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Contributor_filter): [Contributor!]!
    id: String!
    impactDateFrom: BigInt!
    impactDateTo: BigInt!
    impactScopes(first: Int = 100, orderBy: ImpactScope_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ImpactScope_filter): [ImpactScope!]!
    rights(first: Int = 100, orderBy: Right_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Right_filter): [Right!]!
    uri: String!
    version: BigInt!
    workDateFrom: BigInt!
    workDateTo: BigInt!
    workScopes(first: Int = 100, orderBy: WorkScope_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: WorkScope_filter): [WorkScope!]!
}

type HypercertBalance {
    amount: BigInt!
    id: String!
    token: Hypercert!
}

type ImpactScope {
    hypercerts(first: Int = 100, orderBy: Hypercert_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Hypercert_filter): [Hypercert!]!
    id: Bytes!
    text: String!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    contributor(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Contributor
    contributors(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Contributor_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Contributor_filter
    ): [Contributor!]!
    hypercert(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Hypercert
    hypercertBalance(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HypercertBalance
    hypercertBalances(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HypercertBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HypercertBalance_filter
    ): [HypercertBalance!]!
    hypercerts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Hypercert_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Hypercert_filter
    ): [Hypercert!]!
    impactScope(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ImpactScope
    impactScopes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ImpactScope_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ImpactScope_filter
    ): [ImpactScope!]!
    right(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Right
    rights(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Right_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Right_filter
    ): [Right!]!
    workScope(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WorkScope
    workScopes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: WorkScope_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: WorkScope_filter
    ): [WorkScope!]!
}

type Right {
    hypercerts(first: Int = 100, orderBy: Hypercert_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Hypercert_filter): [Hypercert!]!
    id: Bytes!
    text: String!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    contributor(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Contributor
    contributors(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Contributor_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Contributor_filter
    ): [Contributor!]!
    hypercert(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Hypercert
    hypercertBalance(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HypercertBalance
    hypercertBalances(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HypercertBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HypercertBalance_filter
    ): [HypercertBalance!]!
    hypercerts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Hypercert_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Hypercert_filter
    ): [Hypercert!]!
    impactScope(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ImpactScope
    impactScopes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ImpactScope_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ImpactScope_filter
    ): [ImpactScope!]!
    right(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Right
    rights(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Right_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Right_filter
    ): [Right!]!
    workScope(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WorkScope
    workScopes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: WorkScope_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: WorkScope_filter
    ): [WorkScope!]!
}

type WorkScope {
    hypercerts(first: Int = 100, orderBy: Hypercert_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Hypercert_filter): [Hypercert!]!
    id: Bytes!
    text: String!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Timestamp of the block if available, format depends on the chain"
    timestamp: String
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum Contributor_orderBy {
    hypercerts
    id
}

enum HypercertBalance_orderBy {
    amount
    id
    token
}

enum Hypercert_orderBy {
    claimHash
    contributors
    id
    impactDateFrom
    impactDateTo
    impactScopes
    rights
    uri
    version
    workDateFrom
    workDateTo
    workScopes
}

enum ImpactScope_orderBy {
    hypercerts
    id
    text
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum Right_orderBy {
    hypercerts
    id
    text
}

enum WorkScope_orderBy {
    hypercerts
    id
    text
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input Contributor_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    hypercerts_: Hypercert_filter
    id: String
    id_contains: String
    id_contains_nocase: String
    id_ends_with: String
    id_ends_with_nocase: String
    id_gt: String
    id_gte: String
    id_in: [String!]
    id_lt: String
    id_lte: String
    id_not: String
    id_not_contains: String
    id_not_contains_nocase: String
    id_not_ends_with: String
    id_not_ends_with_nocase: String
    id_not_in: [String!]
    id_not_starts_with: String
    id_not_starts_with_nocase: String
    id_starts_with: String
    id_starts_with_nocase: String
}

input HypercertBalance_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    id: String
    id_contains: String
    id_contains_nocase: String
    id_ends_with: String
    id_ends_with_nocase: String
    id_gt: String
    id_gte: String
    id_in: [String!]
    id_lt: String
    id_lte: String
    id_not: String
    id_not_contains: String
    id_not_contains_nocase: String
    id_not_ends_with: String
    id_not_ends_with_nocase: String
    id_not_in: [String!]
    id_not_starts_with: String
    id_not_starts_with_nocase: String
    id_starts_with: String
    id_starts_with_nocase: String
    token: String
    token_: Hypercert_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input Hypercert_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    claimHash: Bytes
    claimHash_contains: Bytes
    claimHash_in: [Bytes!]
    claimHash_not: Bytes
    claimHash_not_contains: Bytes
    claimHash_not_in: [Bytes!]
    contributors: [String!]
    contributors_: Contributor_filter
    contributors_contains: [String!]
    contributors_contains_nocase: [String!]
    contributors_not: [String!]
    contributors_not_contains: [String!]
    contributors_not_contains_nocase: [String!]
    id: String
    id_contains: String
    id_contains_nocase: String
    id_ends_with: String
    id_ends_with_nocase: String
    id_gt: String
    id_gte: String
    id_in: [String!]
    id_lt: String
    id_lte: String
    id_not: String
    id_not_contains: String
    id_not_contains_nocase: String
    id_not_ends_with: String
    id_not_ends_with_nocase: String
    id_not_in: [String!]
    id_not_starts_with: String
    id_not_starts_with_nocase: String
    id_starts_with: String
    id_starts_with_nocase: String
    impactDateFrom: BigInt
    impactDateFrom_gt: BigInt
    impactDateFrom_gte: BigInt
    impactDateFrom_in: [BigInt!]
    impactDateFrom_lt: BigInt
    impactDateFrom_lte: BigInt
    impactDateFrom_not: BigInt
    impactDateFrom_not_in: [BigInt!]
    impactDateTo: BigInt
    impactDateTo_gt: BigInt
    impactDateTo_gte: BigInt
    impactDateTo_in: [BigInt!]
    impactDateTo_lt: BigInt
    impactDateTo_lte: BigInt
    impactDateTo_not: BigInt
    impactDateTo_not_in: [BigInt!]
    impactScopes: [String!]
    impactScopes_: ImpactScope_filter
    impactScopes_contains: [String!]
    impactScopes_contains_nocase: [String!]
    impactScopes_not: [String!]
    impactScopes_not_contains: [String!]
    impactScopes_not_contains_nocase: [String!]
    rights: [String!]
    rights_: Right_filter
    rights_contains: [String!]
    rights_contains_nocase: [String!]
    rights_not: [String!]
    rights_not_contains: [String!]
    rights_not_contains_nocase: [String!]
    uri: String
    uri_contains: String
    uri_contains_nocase: String
    uri_ends_with: String
    uri_ends_with_nocase: String
    uri_gt: String
    uri_gte: String
    uri_in: [String!]
    uri_lt: String
    uri_lte: String
    uri_not: String
    uri_not_contains: String
    uri_not_contains_nocase: String
    uri_not_ends_with: String
    uri_not_ends_with_nocase: String
    uri_not_in: [String!]
    uri_not_starts_with: String
    uri_not_starts_with_nocase: String
    uri_starts_with: String
    uri_starts_with_nocase: String
    version: BigInt
    version_gt: BigInt
    version_gte: BigInt
    version_in: [BigInt!]
    version_lt: BigInt
    version_lte: BigInt
    version_not: BigInt
    version_not_in: [BigInt!]
    workDateFrom: BigInt
    workDateFrom_gt: BigInt
    workDateFrom_gte: BigInt
    workDateFrom_in: [BigInt!]
    workDateFrom_lt: BigInt
    workDateFrom_lte: BigInt
    workDateFrom_not: BigInt
    workDateFrom_not_in: [BigInt!]
    workDateTo: BigInt
    workDateTo_gt: BigInt
    workDateTo_gte: BigInt
    workDateTo_in: [BigInt!]
    workDateTo_lt: BigInt
    workDateTo_lte: BigInt
    workDateTo_not: BigInt
    workDateTo_not_in: [BigInt!]
    workScopes: [String!]
    workScopes_: WorkScope_filter
    workScopes_contains: [String!]
    workScopes_contains_nocase: [String!]
    workScopes_not: [String!]
    workScopes_not_contains: [String!]
    workScopes_not_contains_nocase: [String!]
}

input ImpactScope_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    hypercerts_: Hypercert_filter
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    text: String
    text_contains: String
    text_contains_nocase: String
    text_ends_with: String
    text_ends_with_nocase: String
    text_gt: String
    text_gte: String
    text_in: [String!]
    text_lt: String
    text_lte: String
    text_not: String
    text_not_contains: String
    text_not_contains_nocase: String
    text_not_ends_with: String
    text_not_ends_with_nocase: String
    text_not_in: [String!]
    text_not_starts_with: String
    text_not_starts_with_nocase: String
    text_starts_with: String
    text_starts_with_nocase: String
}

input Right_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    hypercerts_: Hypercert_filter
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    text: String
    text_contains: String
    text_contains_nocase: String
    text_ends_with: String
    text_ends_with_nocase: String
    text_gt: String
    text_gte: String
    text_in: [String!]
    text_lt: String
    text_lte: String
    text_not: String
    text_not_contains: String
    text_not_contains_nocase: String
    text_not_ends_with: String
    text_not_ends_with_nocase: String
    text_not_in: [String!]
    text_not_starts_with: String
    text_not_starts_with_nocase: String
    text_starts_with: String
    text_starts_with_nocase: String
}

input WorkScope_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    hypercerts_: Hypercert_filter
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    text: String
    text_contains: String
    text_contains_nocase: String
    text_ends_with: String
    text_ends_with_nocase: String
    text_gt: String
    text_gte: String
    text_in: [String!]
    text_lt: String
    text_lte: String
    text_not: String
    text_not_contains: String
    text_not_contains_nocase: String
    text_not_ends_with: String
    text_not_ends_with_nocase: String
    text_not_in: [String!]
    text_not_starts_with: String
    text_not_starts_with_nocase: String
    text_starts_with: String
    text_starts_with_nocase: String
}
